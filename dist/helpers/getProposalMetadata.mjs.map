{"version":3,"sources":["../../src/helpers/getProposalMetadata.ts"],"sourcesContent":["import base58 from 'bs58';\nimport matter from 'gray-matter';\n\nimport { HashZero } from './checkHash';\nimport { ProposalMetadata } from './types';\n\nexport const ipfsGateway = 'https://ipfs.io/ipfs';\n\nexport function getLink(hash: string, gateway: string): string {\n  return `${gateway}/${hash}`;\n}\ntype MemorizeMetadata = Record<string, ProposalMetadata>;\n\nconst MEMORIZE: MemorizeMetadata = {};\n\nconst incorectedHashses = [\n  '0x0000000000000000000000000000000000000000000000000000000000000020',\n  HashZero,\n];\n\nexport async function getProposalMetadata(\n  hash: string,\n  gateway = ipfsGateway,\n  setIpfsError?: (hash: string, text?: string) => void,\n  errorText?: string,\n): Promise<ProposalMetadata> {\n  const ipfsHash = hash.startsWith('0x')\n    ? base58.encode(Buffer.from(`1220${hash.slice(2)}`, 'hex'))\n    : hash;\n\n  if (MEMORIZE[ipfsHash]) return MEMORIZE[ipfsHash];\n\n  if (incorectedHashses.some((h) => hash === h)) {\n    if (!!setIpfsError) {\n      setIpfsError(hash, errorText);\n    } else {\n      throw Error('Fetch metadata form ipfs not working');\n    }\n  } else {\n    const ipfsResponse: Response = await fetch(getLink(ipfsHash, gateway));\n\n    if (!ipfsResponse.ok) {\n      if (!!setIpfsError) {\n        setIpfsError(hash);\n      } else {\n        throw Error('Fetch metadata form ipfs not working');\n      }\n    }\n\n    const clone = ipfsResponse.clone();\n    try {\n      const response: ProposalMetadata = await ipfsResponse.json();\n\n      const { content } = matter(response.description);\n\n      MEMORIZE[ipfsHash] = {\n        title: response.title,\n        aip: response.aip,\n        originalIpfsHash: hash,\n        author: response.author,\n        discussions: response.discussions,\n        shortDescription: response.shortDescription,\n        ipfsHash,\n        description: content,\n      };\n    } catch (e) {\n      const text = await clone.text();\n      const { content, data } = matter(text);\n      MEMORIZE[ipfsHash] = {\n        title: data.title,\n        aip: data.aip,\n        originalIpfsHash: hash,\n        author: data.author,\n        discussions: data.discussions,\n        shortDescription: data.shortDescription,\n        ipfsHash,\n        description: content,\n      };\n    }\n  }\n\n  return MEMORIZE[ipfsHash];\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,YAAY;AACnB,OAAO,YAAY;AAEnB,SAAS,gBAAgB;AAGlB,IAAM,cAAc;AAEpB,SAAS,QAAQ,MAAc,SAAyB;AAC7D,SAAO,GAAG,OAAO,IAAI,IAAI;AAC3B;AAGA,IAAM,WAA6B,CAAC;AAEpC,IAAM,oBAAoB;AAAA,EACxB;AAAA,EACA;AACF;AAEA,SAAsB,oBACpB,IAI2B;AAAA,6CAJ3B,MACA,UAAU,aACV,cACA,WAC2B;AAC3B,UAAM,WAAW,KAAK,WAAW,IAAI,IACjC,OAAO,OAAO,OAAO,KAAK,OAAO,KAAK,MAAM,CAAC,CAAC,IAAI,KAAK,CAAC,IACxD;AAEJ,QAAI,SAAS,QAAQ;AAAG,aAAO,SAAS,QAAQ;AAEhD,QAAI,kBAAkB,KAAK,CAAC,MAAM,SAAS,CAAC,GAAG;AAC7C,UAAI,CAAC,CAAC,cAAc;AAClB,qBAAa,MAAM,SAAS;AAAA,MAC9B,OAAO;AACL,cAAM,MAAM,sCAAsC;AAAA,MACpD;AAAA,IACF,OAAO;AACL,YAAM,eAAyB,MAAM,MAAM,QAAQ,UAAU,OAAO,CAAC;AAErE,UAAI,CAAC,aAAa,IAAI;AACpB,YAAI,CAAC,CAAC,cAAc;AAClB,uBAAa,IAAI;AAAA,QACnB,OAAO;AACL,gBAAM,MAAM,sCAAsC;AAAA,QACpD;AAAA,MACF;AAEA,YAAM,QAAQ,aAAa,MAAM;AACjC,UAAI;AACF,cAAM,WAA6B,MAAM,aAAa,KAAK;AAE3D,cAAM,EAAE,QAAQ,IAAI,OAAO,SAAS,WAAW;AAE/C,iBAAS,QAAQ,IAAI;AAAA,UACnB,OAAO,SAAS;AAAA,UAChB,KAAK,SAAS;AAAA,UACd,kBAAkB;AAAA,UAClB,QAAQ,SAAS;AAAA,UACjB,aAAa,SAAS;AAAA,UACtB,kBAAkB,SAAS;AAAA,UAC3B;AAAA,UACA,aAAa;AAAA,QACf;AAAA,MACF,SAAS,GAAG;AACV,cAAM,OAAO,MAAM,MAAM,KAAK;AAC9B,cAAM,EAAE,SAAS,KAAK,IAAI,OAAO,IAAI;AACrC,iBAAS,QAAQ,IAAI;AAAA,UACnB,OAAO,KAAK;AAAA,UACZ,KAAK,KAAK;AAAA,UACV,kBAAkB;AAAA,UAClB,QAAQ,KAAK;AAAA,UACb,aAAa,KAAK;AAAA,UAClB,kBAAkB,KAAK;AAAA,UACvB;AAAA,UACA,aAAa;AAAA,QACf;AAAA,MACF;AAAA,IACF;AAEA,WAAO,SAAS,QAAQ;AAAA,EAC1B;AAAA;","names":[]}